My app is ready, now what? 
Large scale deployments for cloud native applications

9 May 2017

Raffaele Di Fazio
Software Engineer
Zalando SE
raffaele.di.fazio@zalando.de
@x0rg

* Agenda
- The independent developer
- The enterprise
- Containers to the rescue

* Goal
To introduce some problems that go beyond application development which are essential part of the life of a software. To explain how technology plays a big role in solving those problems and why you should care to learn them.

* Real world is hard

* You
- You worked hard to develop your web application, now it's ready!
- How do you make it available on the web? 

* Where: infrastructure
- Phisical server
- IaaS: you get a VM
- PaaS: think only about "the app"
- FaaS: you app is just a function

* What: dependencies
- Which libraries do you need?
- Operating system, does your app run anywhere?
- Other dependencies: DBs, queues, etc.

* Okay, it runs, then what?

* What about updates? 
- What if you need to fix a bug?
- What if you need a new feature? 
- What if you find a security vulnerability? 
- What about the underlying infrastructure updates (kernel, OS, ...)?

* Is a "manual" deploy really an option? 

* What about scale?
- What do you do if you want to scale your application to serve more traffic? 
- How is your deployment strategy linked to that? 
- What about the servers? 
- How do you get new ones? 
- How do you keep them updated? 

* Enterprise world(s)
: There are different kinds of "enterprise", differentiated mostly by the way technology is treated. 

* Case study: Zalando
: If you reached that point you are probably already scared and you want to never deploy anything again. I will present you a case study and show you why it's really not so bad.

* Zalando: Europe's largest online fashion retailer
- 15 countries
- 6 fulfillment centers
- 20 million active customers
- 3.6 billion â‚¬ net sales in 2016
- 165 million visits per month
- 12.000 employees in EU

* Zalando, the tech parts

.image zalando.png 400 _ 

* It's challenging :-)

* What are we looking for? 

- Availability
- Scale
- Speed (rapid iteration)

* What are we really doing this? 
- Small teams 
- Everything has/is an API
- Micro services
- Multi language programming enviroment

* The technical parts: cloud native

* Ingredients
- Use cloud resources
- Design for failures
- Developers can deploy at any time
- Keep the feedback loop short

* How we achieve this

* Containers: the base ingredient
- All of our applications are packaged into (Docker) containers
- Container: "A container image is a lightweight, stand-alone, executable package of a piece of software that includes everything needed to run it: code, runtime, system tools, system libraries."
- Containers share the host kernel
- Not like virtualization, only uses OS features to allow isolating apps as "containers" (CGroups, namespaces)

* Demo
: Show how to launch a docker container, exec into it and see what you see into it, the limited process view

* Okay, tell me more!
- CGroups: resource limits for CPU, Memory, ...
- Namespaces: isolation of PIDs, Users, ...
- Contains everything you need to run (libraries, binaries, etc.)
- Layer based filesystem, based on Copy on Write

* How do you manage containers?

* Cattles not pets
- Treat your containers as something that can and should be replaced
- Get ready to lose them, kill them, replace them
- Never call them by name

* Container Orchestration
- We use [[http://kubernetes.io][Kubernetes]] to orchestrate containers
- Deploy
- Scale
- Self heal

* Demo - deploying an application on Kubernetes

* Questions?
